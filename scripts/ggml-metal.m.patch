--- ggml-metal.m.orig	2023-09-13 12:02:01
+++ ggml-metal.m	2023-09-13 12:02:50
@@ -119,13 +119,13 @@
     metal_printf("%s: allocating\n", __func__);
 
     // Show all the Metal device instances in the system
-    NSArray * devices = MTLCopyAllDevices();
+//    NSArray * devices = MTLCopyAllDevices();
     id <MTLDevice> device;
     NSString * s;
-    for (device in devices) {
-        s = [device name];
-        metal_printf("%s: found device: %s\n", __func__, [s UTF8String]);
-    }
+//    for (device in devices) {
+//        s = [device name];
+//        metal_printf("%s: found device: %s\n", __func__, [s UTF8String]);
+//    }
 
     // Pick and show default Metal device
     device = MTLCreateSystemDefaultDevice();
@@ -191,7 +191,7 @@
 #define WSP_GGML_METAL_ADD_KERNEL(name) \
         ctx->function_##name = [ctx->library newFunctionWithName:@"kernel_"#name]; \
         ctx->pipeline_##name = [ctx->device newComputePipelineStateWithFunction:ctx->function_##name error:&error]; \
-        metal_printf("%s: loaded %-32s %16p | th_max = %4d | th_width = %4d\n", __func__, "kernel_"#name, (void *) ctx->pipeline_##name, \
+        metal_printf("%s: loaded %-32s %16p | th_max = %4d | th_width = %4d\n", __func__, "kernel_"#name, (__bridge void *) ctx->pipeline_##name, \
                 (int) ctx->pipeline_##name.maxTotalThreadsPerThreadgroup, \
                 (int) ctx->pipeline_##name.threadExecutionWidth); \
         if (error) { \
@@ -249,22 +249,20 @@
 #undef WSP_GGML_METAL_ADD_KERNEL
     }
 
-    metal_printf("%s: recommendedMaxWorkingSetSize  = %8.2f MB\n", __func__, ctx->device.recommendedMaxWorkingSetSize / 1024.0 / 1024.0);
-    metal_printf("%s: hasUnifiedMemory              = %s\n",       __func__, ctx->device.hasUnifiedMemory ? "true" : "false");
-    if (ctx->device.maxTransferRate != 0) {
-        metal_printf("%s: maxTransferRate               = %8.2f MB/s\n", __func__, ctx->device.maxTransferRate / 1024.0 / 1024.0);
-    } else {
-        metal_printf("%s: maxTransferRate               = built-in GPU\n", __func__);
-    }
+//    metal_printf("%s: recommendedMaxWorkingSetSize  = %8.2f MB\n", __func__, ctx->device.recommendedMaxWorkingSetSize / 1024.0 / 1024.0);
+//    metal_printf("%s: hasUnifiedMemory              = %s\n",       __func__, ctx->device.hasUnifiedMemory ? "true" : "false");
+//    if (ctx->device.maxTransferRate != 0) {
+//        metal_printf("%s: maxTransferRate               = %8.2f MB/s\n", __func__, ctx->device.maxTransferRate / 1024.0 / 1024.0);
+//    } else {
+//        metal_printf("%s: maxTransferRate               = built-in GPU\n", __func__);
+//    }
 
     return ctx;
 }
 
 void wsp_ggml_metal_free(struct wsp_ggml_metal_context * ctx) {
     metal_printf("%s: deallocating\n", __func__);
-#define WSP_GGML_METAL_DEL_KERNEL(name) \
-    [ctx->function_##name release]; \
-    [ctx->pipeline_##name release];
+#define WSP_GGML_METAL_DEL_KERNEL(name)
 
     WSP_GGML_METAL_DEL_KERNEL(add);
     WSP_GGML_METAL_DEL_KERNEL(add_row);
@@ -315,16 +313,6 @@
 
 #undef WSP_GGML_METAL_DEL_KERNEL
 
-    for (int i = 0; i < ctx->n_buffers; ++i) {
-        [ctx->buffers[i].metal release];
-    }
-
-    [ctx->library release];
-    [ctx->queue release];
-    [ctx->device release];
-
-    dispatch_release(ctx->d_queue);
-
     free(ctx);
 }
 
@@ -457,16 +445,16 @@
                 ++ctx->n_buffers;
             }
         }
-
-        metal_printf(", (%8.2f / %8.2f)",
-                ctx->device.currentAllocatedSize / 1024.0 / 1024.0,
-                ctx->device.recommendedMaxWorkingSetSize / 1024.0 / 1024.0);
 
-        if (ctx->device.currentAllocatedSize > ctx->device.recommendedMaxWorkingSetSize) {
-            metal_printf(", warning: current allocated size is greater than the recommended max working set size\n");
-        } else {
-            metal_printf("\n");
-        }
+//        metal_printf(", (%8.2f / %8.2f)",
+//                ctx->device.currentAllocatedSize / 1024.0 / 1024.0,
+//                ctx->device.recommendedMaxWorkingSetSize / 1024.0 / 1024.0);
+//
+//        if (ctx->device.currentAllocatedSize > ctx->device.recommendedMaxWorkingSetSize) {
+//            metal_printf(", warning: current allocated size is greater than the recommended max working set size\n");
+//        } else {
+//            metal_printf("\n");
+//        }
     }
 
     return true;
